% ==========================================
% FILE: assign3data1.m (Data Generation)
% ==========================================
%this program is a shell program that allows for differences in intercept
%terms over time which are unobserved to the econmetrician.  The first set
%of lines allow the user to change
%1) the number of observations per time period,
%2) the number of time periods, 
%3) the number of unobserved states which for now needs to be set at 2, 
%4) the coefficients on the unobserved states,
%5) the transitions on the unobserved states, and
%6) the initial conditions
%7) the number of times the user wants to run the simulation
%throughout the variance on the epsilon's is set to 1
clear
N=5000;
T=5;
S=2;
b=[7;1;-.3;-.7;-.5;-1;.3;1.5];
p2=[.8 .2;.3 .7];
prior2=.8;
Nsim=1;
Util=zeros(8,1);
Util(1)=b(5);
Util(2)=b(5)+b(6); %b(6) is the high transitory state
Util(3)=b(5)+b(7); %b(7) is the high permanent state
Util(4)=b(5)+b(6)+b(7); 
Util(5:8)=Util(1:4)-b(8); %b(8) is the entry cost

%Now taking the entries above and finding what the probabilities of
%entering and exiting are for each of the states

%Util is written as:
%(1:4) low state low pstate monopoly incumbent, high state low pstate monopoly incumbent, low state 
%high pstate monopoly incumbent, high state high pstate monopoly incumbent
%(5:8) same as above but entrant instead of incumbent

EV=.25;
beta=.9;
xi=exp(Util+beta*EV)./(1+exp(Util+beta*EV));

xi=prob3(Util,p2);

bfin=[];

p=p2;

%now taking the entries above and creating the data
%First creating the data on the states    
Draw=rand(N,T);
State=zeros(N,T);
State(:,1)=Draw(:,1)>sum(prior2);

t=2;
while t<T+1
    State(:,t)=Draw(:,t)<(p(1,2)+State(:,t-1)*(p(2,2)-p(1,2)));
    t=t+1;
end

PState=(rand(N,1)>.5)*ones(1,T);

%Now creating the data on the entry/exit decisions
Firm1=zeros(N,T);

draws1=rand(N,T);

tic

n=1;
while n<N+1;
    
Firm1(n,1)=(draws1(n,1)<xi(5+State(n,1)+2*PState(n,1)));

n=n+1;
end

toc

tic
%Firm1c=getfirm(State(:,1),PState(:,1),xi,draws1(:,1));
toc
%Now Creating the code to map from the possible states to the data

LFirm1=[zeros(N,1) Firm1(:,1:T-1)];

n=1;
while n<N+1
    
    t=2;
    while t<T+1;
        
        Firm1(n,t)=(draws1(n,t)<xi(5+State(n,t)+2*PState(n,1)-4*LFirm1(n,t)));
        if t<T
        LFirm1(n,t+1)=Firm1(n,t);
        end
        t=t+1;
    end
    
    n=n+1;
end

%Now creating the price variable
Epsilon=randn(N,T);
Y=b(1)+b(2)*State+b(3)*PState+b(4)*Firm1+Epsilon;
PState=PState(:,1);
save dataassign32 Firm1 PState State Y

% ==========================================
% FILE: assign3prob1.m (Observed States)
% ==========================================
clear
load dataassign32

%first getting transitions on State

[N,T]=size(State)
LState=State(:,1:T-1);

LState2=reshape(LState,N*(T-1),1);
State2=reshape(State(:,2:T),N*(T-1),1);

p=[mean(State2(LState2==0)==0) mean(State2(LState2==0)==1);mean(State2(LState2==1)==0) mean(State2(LState2==1)==1)]

%now getting the CCP's

State2=reshape(State,N*T,1);

LFirm=[zeros(N,1) Firm1(:,1:T-1)];

LFirm2=reshape(LFirm,N*T,1);
Firm2=reshape(Firm1,N*T,1);
PState2=kron(ones(T,1),PState(:,1));

i=1;

while i<3
    
    j=1;
    
    while j<3
        
        k=1;
        
        while k<3
            
            xi2(k+2*(j-1)+4*(i-1))=mean(Firm2(LFirm2==(2-i)&PState2==(j-1)&State2==(k-1)));
            
            k=k+1;
        end
        j=j+1;
    end
    i=i+1;
end

%creating future value terms

eul=.5772;

    EV(1)=-eul+p(1,1)*log(1-xi2(1))+p(1,2)*log(1-xi2(2));
    EV(2)=-eul+p(2,1)*log(1-xi2(1))+p(2,2)*log(1-xi2(2));    
    EV(3)=-eul+p(1,1)*log(1-xi2(3))+p(1,2)*log(1-xi2(4));
    EV(4)=-eul+p(2,1)*log(1-xi2(3))+p(2,2)*log(1-xi2(4));
    
FV=EV(1).*(1-PState2).*(1-State2)+EV(2).*State2.*(1-PState2)+EV(3).*(1-State2).*PState2+EV(4).*State2.*PState2;
beta=.9;
FV=-beta*(FV);

b=zeros(4,1);

[b,l,e,o,g,h]=fminunc('logitCCP',b,[],Firm2,[ones(size(Firm2,1),1) State2 PState2 1-LFirm2],FV);

% ==========================================
% FILE: assign3prob2.m (Missing Permanent State)
% ==========================================
clear
load dataassign32



%first getting transitions on State

[N,T]=size(State)
LState=State(:,1:T-1);

LState2=reshape(LState,N*(T-1),1);
State2=reshape(State(:,2:T),N*(T-1),1);

p=[mean(State2(LState2==0)==0) mean(State2(LState2==0)==1);mean(State2(LState2==1)==0) mean(State2(LState2==1)==1)]

%now getting the CCP's

State2=kron(ones(2,1),reshape(State,N*T,1));

LFirm=[zeros(N,1) Firm1(:,1:T-1)];

LFirm2=kron(ones(2,1),reshape(LFirm,N*T,1));
Firm2=kron(ones(2,1),reshape(Firm1,N*T,1));
PState2=[zeros(N*T,1);ones(N*T,1)];

%means of updating the CCP's: 1=data, 2=likelihood

update=1

while update<3

i=1;

while i<3
    
    j=1;
    
    while j<3
        
        k=1;
        
        while k<3
            
            xi2(k+2*(j-1)+4*(i-1))=mean(Firm2(LFirm2==(2-i)&PState2==(j-1)&State2==(k-1)));
            
            k=k+1;
        end
        j=j+1;
    end
    i=i+1;
end

%creating future value terms

eul=.5772;

    EV(1)=-eul+p(1,1)*log(1-xi2(1))+p(1,2)*log(1-xi2(2));
    EV(2)=-eul+p(2,1)*log(1-xi2(1))+p(2,2)*log(1-xi2(2));    
    EV(3)=-eul+p(1,1)*log(1-xi2(3))+p(1,2)*log(1-xi2(4));
    EV(4)=-eul+p(2,1)*log(1-xi2(3))+p(2,2)*log(1-xi2(4));
    
FV=EV(1).*(1-PState2).*(1-State2)+EV(2).*State2.*(1-PState2)+EV(3).*(1-State2).*PState2+EV(4).*State2.*PState2;
beta=.9;
FV=-beta*(FV);

b2=[7;1;-.5;-.7];
b=[-.5;-1;.6;1.5];
var=1;

X2=[ones(N*T*2,1) State2 PState2 1-LFirm2];
Y2=kron(ones(2,1),reshape(Y,N*T,1));
X22=[ones(N*T*2,1) State2 PState2 Firm2];

prior=[.5 .5];

PType=.5*ones(N*T*2,1);
oPType=zeros(N*T*2,1);

j=1;
while (max(abs(PType-oPType)))>.00001

    oPType=PType;
    
        [prior,PType]=typeprob0806p(prior,N,T,2,'logitCCPucalc',b,Firm2,X2,FV,b2,Y2,X22,var);
        
        if update==1
            [FV]=updateCCPu(b,Firm2,State2,PState2,LFirm2,PType,p);
            if j==1
               FVu=FV;
            end
        end
        if update==2
            [FV,xi2]=updateCCPu2(b,Firm2,State2,PState2,LFirm2,p,xi2);
            if j==1
                FVu=FV;
            end
        end
            
        [b2,var]=wols(Y2,X22,PType,N*T);

    [b]=fminunc('logitCCPu',b,[],Firm2,X2,FV,PType);

    j=j+1;
%    (max(abs(PType-oPType)))

end

if update==1
bd=b;
bd2=b2;
vard=var;
jd=j;
end
update=update+1
end

[b bd]

[bd2 b2]

[vard var]

% ==========================================
% FILE: assign3prob3.m (Missing Transitory State)
% ==========================================
clear
load dataassign32

%first getting transitions on State

[N,T]=size(State)
LState=State(:,1:T-1);

LState2=reshape(LState,N*(T-1),1);
State2=reshape(State(:,2:T),N*(T-1),1);

p=[.8 .2;.3 .7];%[mean(State2(LState2==0)==0) mean(State2(LState2==0)==1);mean(State2(LState2==1)==0) mean(State2(LState2==1)==1)]

%now getting the CCP's

PState=PState*ones(1,T);

PState2=kron(ones(2,1),reshape(PState,N*T,1));

LFirm=[zeros(N,1) Firm1(:,1:T-1)];

LFirm2=kron(ones(2,1),reshape(LFirm,N*T,1));
Firm2=kron(ones(2,1),reshape(Firm1,N*T,1));
State2=[zeros(N*T,1);ones(N*T,1)];

%State2=[reshape(State,N*T,1);reshape(State,N*T,1)];

i=1;

while i<3
    
    j=1;
    
    while j<3
        
        k=1;
        
        while k<3
            
            xi2(k+2*(j-1)+4*(i-1))=mean(Firm2(LFirm2==(2-i)&PState2==(j-1)&State2==(k-1)));
            
            k=k+1;
        end
        j=j+1;
    end
    i=i+1;
end

%creating future value terms

eul=.5772;

    EV(1)=-eul+p(1,1)*log(1-xi2(1))+p(1,2)*log(1-xi2(2));
    EV(2)=-eul+p(2,1)*log(1-xi2(1))+p(2,2)*log(1-xi2(2));    
    EV(3)=-eul+p(1,1)*log(1-xi2(3))+p(1,2)*log(1-xi2(4));
    EV(4)=-eul+p(2,1)*log(1-xi2(3))+p(2,2)*log(1-xi2(4));
    
FV=EV(1).*(1-PState2).*(1-State2)+EV(2).*State2.*(1-PState2)+EV(3).*(1-State2).*PState2+EV(4).*State2.*PState2;
beta=.9;
FV=-beta*(FV);

b2=[7;1;-.3;-.7];
b=[-.5;-1;.3;1.5];
var=1;

X2=[ones(N*T*2,1) State2 PState2 1-LFirm2];
Y2=kron(ones(2,1),reshape(Y,N*T,1));
X22=[ones(N*T*2,1) State2 PState2 Firm2];

prior=[.8 .2];

PType=.5*ones(N*T*2,1);
oPType=zeros(N*T*2,1);
[Likemp]=updateCCPu(b,Firm2,State2,PState2,LFirm2,PType,p);
o1=optimset('Display','off');

j=1;
while  (max(abs(PType-oPType)))>.00001

    oPType=PType;

        [prior,p,PType]=typeprob0806(prior,p,N,T,2,'logitCCPucalc',0,[],b,Firm2,X2,FV,b2,Y2,X22,var);
      
            [FV,xi2]=updateCCPu2(b,Firm2,State2,PState2,LFirm2,p,xi2);

            
        [b2,var]=wols(Y2,X22,PType,N*T);

    [b]=fminunc('logitCCPu',b,[],Firm2,X2,FV,PType);
b
    j=j+1
%    (max(abs(PType-oPType)))

end

% ==========================================
% FILE: assign3prob4.m (Two-Stage Estimation)
% ==========================================
clear
load dataassign3

%first getting transitions on State

[N,T]=size(State)
LState=State(:,1:T-1);

LState2=reshape(LState,N*(T-1),1);
State2=reshape(State(:,2:T),N*(T-1),1);

p=[.7 .3;.3 .7];%[mean(State2(LState2==0)==0) mean(State2(LState2==0)==1);mean(State2(LState2==1)==0) mean(State2(LState2==1)==1)]

%now getting the CCP's

PState=PState*ones(1,T);

PState2=kron(ones(2,1),reshape(PState,N*T,1));

LFirm=[zeros(N,1) Firm1(:,1:T-1)];

LFirm2=kron(ones(2,1),reshape(LFirm,N*T,1));
Firm2=kron(ones(2,1),reshape(Firm1,N*T,1));
State2=[zeros(N*T,1);ones(N*T,1)];


i=1;

while i<3
    
    j=1;
    
    while j<3
        
        k=1;
        
        while k<3
            
            xi2(k+2*(j-1)+4*(i-1))=mean(Firm2(LFirm2==(2-i)&PState2==(j-1)&State2==(k-1)));
            
            k=k+1;
        end
        j=j+1;
    end
    i=i+1;
end

%creating future value terms

eul=.5772;

    EV(1)=-eul+p(1,1)*log(1-xi2(1))+p(1,2)*log(1-xi2(2));
    EV(2)=-eul+p(2,1)*log(1-xi2(1))+p(2,2)*log(1-xi2(2));    
    EV(3)=-eul+p(1,1)*log(1-xi2(3))+p(1,2)*log(1-xi2(4));
    EV(4)=-eul+p(2,1)*log(1-xi2(3))+p(2,2)*log(1-xi2(4));
    
FV=EV(1).*(1-PState2).*(1-State2)+EV(2).*State2.*(1-PState2)+EV(3).*(1-State2).*PState2+EV(4).*State2.*PState2;
beta=.9;
FV=-beta*(FV);

b2=[6.5;1;-.3;-.7];
b=[-.5;-1;.3;1.5];
var=1;

X2=[ones(N*T*2,1) State2 PState2 1-LFirm2];
Y2=kron(ones(2,1),reshape(Y,N*T,1));
X22=[ones(N*T*2,1) State2 PState2 Firm2];

prior=[.5 .5];

PType=.5*ones(N*T*2,1);
oPType=zeros(N*T*2,1);
[Likemp]=updateCCPu(b,Firm2,State2,PState2,LFirm2,PType,p);
o1=optimset('Display','off');

j=1;
while (max(abs(PType-oPType)))>.00001

    oPType=PType;
    
    k=1;
    while k<26
        [prior,p,PType]=typeprob0806(prior,p,N,T,2,'likeCCP2stage',0,[],Likemp,b2,Y2,X22,var);
        
        [Likemp]=updateCCPu2stage(b,Firm2,State2,PState2,LFirm2,PType,p);
    k=k+1;
    end
    prior        
    
        [b2,var]=wols(Y2,X22,PType,N*T);

    %

    j=j+1
%    (max(abs(PType-oPType)))

end
[FV]=updateCCPu(b,Firm2,State2,PState2,LFirm2,PType,p);
[b]=fminunc('logitCCPu',b,o1,Firm2,X2,FV,PType);

% ==========================================
% FILE: logitCCP.m
% ==========================================
function llv=logitCCP(b,Y,X,FV)

v1=X*b+FV;

llv=sum(log(exp(v1)+1)-Y.*v1);

% ==========================================
% FILE: logitCCPu.m
% ==========================================
function llv=logitCCPu(b,Y,X,FV,PType)

v1=X*b+FV;

llv=PType'*(log(1+exp(v1))-Y.*v1);

% ==========================================
% FILE: logitCCPucalc.m
% ==========================================
function Like=logitCCPucalc(b,Y,X,FV,b2,Y2,X2,var)

v1=X*b+FV;

LikeC=(exp(v1).^Y)./(1+exp(v1));

Eprice=X2*b2;

LikeP=normpdf(Y2-Eprice,0,var);

Like=LikeC.*LikeP;

% ==========================================
% FILE: likeCCP2stage.m
% ==========================================
function Like=likeCCP2stage(LikeC,b2,Y2,X2,var)


Eprice=X2*b2;

LikeP=normpdf(Y2-Eprice,0,var);

Like=LikeC.*LikeP;

% ==========================================
% FILE: typeprob0806.m (Hamilton Filter)
% ==========================================
function [prior,trans2,PType]=typeprob0806(prior,trans,N,T,S,FUN,inc,INITIALC,varargin);

%the program takes as inputs:
%1) the distribution of initial conditions (N x S)
%2) the transition matrix on the unobservables (S x S)
%3) the number of observations in the data set (N), the number of time
%periods (T), and the number of unobserved states (S)
%4) the likelihood function (FUN) the returns an N x T x S matrix
%5) a flag (inc) for whether there is a program that allows the initial conditions to vary across states
%(INITIALC)
%6) all variables related to calculating the likelihood and allowing the initial conditions to vary

%
%the program returns:
%1) the updated initial conditions and the updated unobservable transition
%matrix
%2) the conditoin probability of each observation being in one of the
%observed states, PType (N x T x S)

%First getting the likelihoods.
[Like]=feval(FUN,varargin{:});
Like=reshape(Like,N,T,S);
%In order to update the type probabilities at time t, need to be able to
%incorporate information from periods after t and from periods before t
%
%pback gives the contribution from periods after t

pback=ones(N,T,S);
pback(:,T,:)=Like(:,T,:);


t=T-1;
while t>0
    s1=1;
    while s1<S+1
        temp=0;
        s2=1;
        while s2<S+1
            temp=temp+pback(:,t+1,s2)*trans(s1,s2);
            s2=s2+1;
        end
        pback(:,t,s1)=temp.*Like(:,t,s1);
        s1=s1+1;
    end
    t=t-1;
end

%pfor gives the contribution from periods before t

pfor=ones(size(Like));

s=1;
while s<S+1
    pfor(:,1,s)=prior(:,s).*Like(:,1,s);
    s=s+1;
end

t=2;
while t<T+1
    s2=1;
    while s2<S+1;
        temp=0;
        s1=1;
        while s1<S+1;
            temp=temp+pfor(:,t-1,s1)*trans(s1,s2);
            s1=s1+1;
        end
        pfor(:,t,s2)=temp.*Like(:,t,s2);
        s2=s2+1;
    end
    t=t+1;
end

%Using pfor and pack we can now calculate the conditional probability of
%being in each unobserved state for each observation

PType=zeros(size(Like));

dem=sum(pfor.*pback./Like,3);

s=1;
while s<S+1
    PType(:,:,s)=(pfor(:,:,s).*pback(:,:,s)./Like(:,:,s))./dem;
    s=s+1;
end

%Now we update the transition probabilities following Hamilton (1990)
%page 54.  The numerator for the update for the (j,k) term in the
%transition matrix multiplies two terms 1) the probability of being in
%unobserved state k conditional on all past and future choices and
%conditional on being in state j at time t-1 2) the probability of being in
%the unobserved state j at time t-1 conditional on all past and future
%choices. These calculations are made for each individual at each time
%period and then summed.  The denominator then sums across all individuals
%and all time periods the expression in 2).  "All time periods" here actually
%refers to all time periods besides the first.

trans2=trans;

s1=1;
while s1<S+1
    dem=0;
    s2=1;
    while s2<S+1
        dem=dem+trans(s1,s2)*pback(:,2:T,s2);
        s2=s2+1;
    end
    s2=1;
    while s2<S+1
        trans2(s1,s2)=sum(sum(PType(:,1:(T-1),s1).*(trans(s1,s2)*pback(:,2:T,s2)./dem),2))./sum(sum(PType(:,1:(T-1),s1),2));
        s2=s2+1;
    end
    s1=s1+1;
end

%The last step is to update the initial conditions the program INITIALC
%must return an N x S matrix

basep=squeeze(PType(:,1,:));
if inc==1
    prior=feval(INITIALC,basep,varargin{:});
else
    prior=mean(basep);
end


PType=reshape(PType,(N*T*S),1);

% ==========================================
% FILE: typeprob0806p.m (Permanent Heterogeneity)
% ==========================================
function [prior,PType,flike]=typeprob0806p(prior,N,T,S,FUN,varargin);

%the program takes as inputs:
%1) the distribution of initial conditions (1 x S)
%2) the number of observations in the data set (N), the number of time
%periods (T), and the number of unobserved states (S)
%3) the likelihood function (FUN) the returns an (N x T x S) x 1 matrix
%4) all variables related to calculating the likelihood

%
%the program returns:
%1) the updated prior 
%2) the conditional probability of each observation being in one of the
%unobserved states, PType ((N x T) x S)
%3) the updated FV terms

[Like]=feval(FUN,varargin{:});

Like2=reshape(Like,N,T,S);

base=squeeze(prod(Like2,2));

s=1;

while s<S+1

    PType(:,s)=(prior(s)*base(:,s))./(base*(prior'));
    
    s=s+1;
end

prior=mean(PType);

%PType=reshape(PType,N*S,1);

PType=kron(ones(T,1),PType);

PType=reshape(PType,(N*T*S),1);

flike=PType'*log(Like);

% ==========================================
% FILE: updateCCPu.m
% ==========================================
function FV=updataCCPu(b,Firm2,State2,PState2,LFirm2,PType,p)

i=1;

while i<3
   
    j=1;
    
    while j<3
        
        k=1;
        
        while k<3
            index=(LFirm2==(2-i)).*(PState2==(j-1)).*(State2==(k-1));

            xi2(k+2*(j-1)+4*(i-1))=(PType(index==1)'*Firm2(index==1))./sum(PType(index==1));
            
            k=k+1;
        end
        j=j+1;
    end
    i=i+1;
end

%creating future value terms

eul=.5772;

    EV(1)=-eul+p(1,1)*log(1-xi2(1))+p(1,2)*log(1-xi2(2));
    EV(2)=-eul+p(2,1)*log(1-xi2(1))+p(2,2)*log(1-xi2(2));    
    EV(3)=-eul+p(1,1)*log(1-xi2(3))+p(1,2)*log(1-xi2(4));
    EV(4)=-eul+p(2,1)*log(1-xi2(3))+p(2,2)*log(1-xi2(4));
    
FV=EV(1).*(1-PState2).*(1-State2)+EV(2).*State2.*(1-PState2)+EV(3).*(1-State2).*PState2+EV(4).*State2.*PState2;
beta=.9;
FV=-beta*(FV);

% ==========================================
% FILE: updateCCPu2.m
% ==========================================
function [FV,xi2]=updateCCPu2(b,Firm2,State2,PState2,LFirm2,trans,xi);

%Util is written as:
%(1:4) low state low pstate monopoly incumbent, high state low pstate monopoly incumbent, low state 
%high pstate monopoly incumbent, high state high pstate monopoly incumbent
%(5:8) same as above but entrant instead of incumbent

Util=zeros(8,1);
Util(1)=b(1);
Util(2)=b(1)+b(2); %b(2) is the high transitory state
Util(3)=b(1)+b(3); %b(3) is the high permanent state
Util(4)=b(1)+b(2)+b(3); 
Util(5:8)=Util(1:4)-b(4); %b(4) is the entry cost

eul=.5772;

beta=.9;

v=zeros(8,1);
v2=v;
%calculating the probability of making various choices given the current
%state

    EV(1)=-eul+trans(1,1)*log(1-xi(1))+trans(1,2)*log(1-xi(2));
    EV(2)=-eul+trans(2,1)*log(1-xi(1))+trans(2,2)*log(1-xi(2));    
    EV(3)=-eul+trans(1,1)*log(1-xi(3))+trans(1,2)*log(1-xi(4));
    EV(4)=-eul+trans(2,1)*log(1-xi(3))+trans(2,2)*log(1-xi(4));
    v2(1)=Util(1)-beta*EV(1);
    v2(2)=Util(2)-beta*EV(2);
    v2(3)=Util(3)-beta*EV(3);
    v2(4)=Util(4)-beta*EV(4);
    v2(5)=Util(5)-beta*EV(1);
    v2(6)=Util(6)-beta*EV(2);
    v2(7)=Util(7)-beta*EV(3);
    v2(8)=Util(8)-beta*EV(4);
    xi2=exp(v2)./(1+exp(v2));




FV=zeros(50000,1);


i=1;

while i<3
   
    j=1;
    
    while j<3
        
        index(:,1)=(PState2==(j-1)).*(State2==(i-1));
        FV(index==1)=EV(i+2*(j-1));

        j=j+1;
    end
    i=i+1;
end


beta=.9;
FV=-beta*(FV);

% ==========================================
% FILE: updateCCPu2stage.m
% ==========================================
function Likemp=updataCCPu2stage(b,Firm2,State2,PState2,LFirm2,PType,p)

Likemp=zeros(size(Firm2,1),1);

i=1;

while i<3
   
    j=1;
    
    while j<3
        
        k=1;
        
        while k<3
            index=(LFirm2==(2-i)).*(PState2==(j-1)).*(State2==(k-1));

            xitemp=(PType(index==1)'*Firm2(index==1))./sum(PType(index==1));
 
            xi2(k+2*(j-1)+4*(i-1))=xitemp;
            
            Likemp(index==1)=Firm2(index==1).*xitemp+(1-Firm2(index==1)).*(1-xitemp);
            
            k=k+1;
        end
        j=j+1;
    end
    i=i+1;
end

% ==========================================
% FILE: prob3.m
% ==========================================
function [p]=prob3(Util,trans)

%Util is written as:
%(1:4) low state low pstate monopoly incumbent, high state low pstate monopoly incumbent, low state 
%high pstate monopoly incumbent, high state high pstate monopoly incumbent
%(5:8) same as above but entrant instead of incumbent

eul=.5772;
EV=.25;
beta=.9;
p=exp(Util+beta*EV)./(1+exp(Util+beta*EV));
p0=[zeros(8,1)];

v=zeros(8,1);
v2=v;
%calculating the probability of making various choices given the current
%state

while abs(max(abs(p0-p)))>.000001;
    p0=p;
    EV(1)=-eul+trans(1,1)*log(1-p(1))+trans(1,2)*log(1-p(2));
    EV(2)=-eul+trans(2,1)*log(1-p(1))+trans(2,2)*log(1-p(2));    
    EV(3)=-eul+trans(1,1)*log(1-p(3))+trans(1,2)*log(1-p(4));
    EV(4)=-eul+trans(2,1)*log(1-p(3))+trans(2,2)*log(1-p(4));
    v2(1)=Util(1)-beta*EV(1);
    v2(2)=Util(2)-beta*EV(2);
    v2(3)=Util(3)-beta*EV(3);
    v2(4)=Util(4)-beta*EV(4);
    v2(5)=Util(5)-beta*EV(1);
    v2(6)=Util(6)-beta*EV(2);
    v2(7)=Util(7)-beta*EV(3);
    v2(8)=Util(8)-beta*EV(4);
    p=exp(v2)./(1+exp(v2));

end

% ==========================================
% FILE: wols.m
% ==========================================
function [b,sigma]=wols(y,x,PType,N)

b=inv((PType*ones(1,size(x,2)).*x)'*x)*(x'*(PType.*y));

sigma=PType'*((y-x*b).^2)./N;
sigma=sigma.^.5;